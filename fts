#!/usr/bin/env python3.2

import sys
import argparse
import requests
import json
import hashlib
import os

json._default_encoder = json.JSONEncoder(
  skipkeys=False,
  ensure_ascii=True,
  check_circular=True,
  allow_nan=True,
  indent=None,
  separators=(',', ':'),
  default=None,
)

server_list = []
new_cert = dict(filename="", submissions=[], blocks=[], master_blocks=[])

class TimestampServer:
  def __init__(self, api_url):
    self.api_url = api_url

  def _api_url(self, path):
    return self.api_url + path

  def _api_timestamps_new(self):
    return self.api_url + '/timestamps/new'

  def _api_timestamps(self):
    return self.api_url + '/timestamps'
    
  def _api_timestamp(self, id):
    return self.api_url + "/timestamps/%d" % id
    
  def _api_timestamp_by_hash(self, hash):
    return self.api_url + "/timestamps/%s" % hash

  def prepare_submission(self):
    try:
      r = requests.get(self._api_timestamps_new())
      prepare_data = json.loads(r.text)
      return prepare_data['master_id'], prepare_data['salt']
    except ValueError:
      print("Could not communicate with server correctly. Do you have a valid url to a timestamp server?")
      exit()
    

  def submit_timestamp(self, hash, master_id):
    r = requests.post(self._api_timestamps(), 
      data={'hash': hash, 'master_block_id': master_id})
    res = json.loads(r.text)
    if 'error' in res:
      print("Submission failed: %s" % response['error'])
      return res
    else:
      print(r.text)
      return res

    
  def get_timestamp(self, id):
    r = requests.get(self._api_timestamp(id))
    res = json.loads(r.text)
    return res['timestamp']
    
  def get_timestamp_by_hash(self, hash):
    r = requests.get(self._api_timestamp_by_hash(hash))
    res = json.loads(r.text)
    return res['timestamp']


class TimestampRequest:
  def __init__(self, file):
    self.encoded_data = file.read().encode()
  
  def make_hash(self, data, salt):
    hasher = hashlib.sha512()
    hasher.update(salt)
    hasher.update(data)
    return hasher.hexdigest()
  
  def submit_to(self, server):
    master_id, salt = server.prepare_submission()
    hash = self.make_hash(self.encoded_data, salt.encode())
    res = server.submit_timestamp(hash, master_id)
    res["salt"] = salt
    res["server"] = server.api_url
    return res

def check_cert(tscert, filename=None):
  cert = None
  if os.path.isfile(tscert):
    try:
      f = open(tscert, "r+")
      cert = json.loads(f.read())
      if cert['filename'] is not filename and filename is not None:
        ok = input("Warning! The certificate file you specified has another filename in it. Are you sure you want to proceed? (y/n): ")
        print(ok)
        if not ok == "y" and not ok == "Y":
          print("Exiting!")
          exit()
      f.close()
    except ValueError:
      print("Malformed Certificate File! Exiting!")
      exit()
  else:
    cert = new_cert
    cert["filename"] = filename
  return cert
  
def update_cert(cert_file, cert):
  f = open(cert_file, "w")
  f.write(json.dumps(cert))
  f.close()
  #print(cert)

def do_submit(args):
  cert_file = args.cert or args.file.name + '.tscert'
  cert = check_cert(cert_file, args.file.name)
  request = TimestampRequest(args.file)
  for server in server_list:
    res = request.submit_to(server)
    if not 'error' in res:
      cert["submissions"].append(res)
  update_cert(cert_file, cert)
  
def load_config():
  global server_list
  home = os.getenv('USERPROFILE') or os.getenv('HOME')
  config_file = home + '/.ftsconfig'
  if os.path.isfile(config_file):
    try:
      f = open(config_file)
      config = json.loads(f.read())
      f.close()
      for server in config['Servers']:
        server_list.append(TimestampServer(server))
    except ValueError:
      print("Could not load config file! Malformed JSON!")
      exit()
  else:
    f = open(config_file, 'w')
    f.write("{\n\"Servers\": \n[\"http://fts-ruby.herokuapp.com/api/v1\"]\n}")
    f.close()
    server_list = [TimestampServer("http://fts-ruby.herokuapp.com/api/v1")]

#def do_certificate(args):

#def do_verify(args):
#  request = TimestampRequest(args.file)
#  for server in server_list:
#    ts = request.search_for_hash(server)

# setup command line parser
parser = argparse.ArgumentParser(prog='fts')
parser.add_argument('-c', '--cert')
parser.add_argument('-s', '--server')
cmdparsers = parser.add_subparsers()

# 'submit' command parser
parser_submit = cmdparsers.add_parser('submit')
parser_submit.add_argument('file', type=argparse.FileType('r'))
parser_submit.set_defaults(func=do_submit)

# 'verify' command parserserver_list = [TimestampServer('http://fts-ruby.herokuapp.com')]
#parser_verify = cmdparsers.add_parser('verify')
#parser_verify.add_argument('file', type=argparse.FileType('r'))
#parser_verify.set_defaults(func=do_verify)

# do it live!
if __name__ == "__main__":
  load_config()  
  args = parser.parse_args()
  if args.server is not None:
    server_list = [TimestampServer(args.server)]
  sys.exit( args.func(args) )
