#!/usr/bin/env python3.2

import sys
import argparse
import requests
import json
import hashlib
import os.path

json._default_encoder = json.JSONEncoder(
  skipkeys=False,
  ensure_ascii=True,
  check_circular=True,
  allow_nan=True,
  indent=None,
  separators=(',', ':'),
  default=None,
)

class TimestampServer:
  def __init__(self, api_url):
    self.api_url = api_url

  def _api_url(self, path):
    return self.api_url + path

  def _api_timestamps_new(self):
    return self.api_url + '/timestamps/new'

  def _api_timestamps(self):
    return self.api_url + '/timestamps'
    
  def _api_timestamp(self, id):
    return self.api_url + "/timestamps/%d" % id
    
  def _api_timestamp_by_hash(self, hash):
    return self.api_url + "/timestamps/%s" % hash

  def prepare_submission(self):
    r = requests.get(self._api_timestamps_new())
    prepare_data = json.loads(r.text)
    return prepare_data['master_id'], prepare_data['salt']

  def submit_timestamp(self, hash, master_id):
    r = requests.post(self._api_timestamps(), 
      data={'hash': hash, 'master_block_id': master_id})
    response = json.loads(r.text)
    if response['success']:
      r = requests.get(self._api_timestamp(response['new_timestamp_id']))
      print(r.text)
    else:
      print("Submission failed: %s" % response['error'])

    
  def get_timestamp(self, id):
    r = requests.get(self._api_timestamp(id))
    res = json.loads(r.text)
    return res['timestamp']
    
  def get_timestamp_by_hash(self, hash):
    r = requests.get(self._api_timestamp_by_hash(hash))
    res = json.loads(r.text)
    return res['timestamp']


class TimestampRequest:
  def __init__(self, file):
    self.encoded_data = file.read().encode()
  
  def make_hash(self, data, salt):
    hasher = hashlib.sha512()
    hasher.update(salt)
    hasher.update(data)
    return hasher.hexdigest()
  
  def submit_to(self, server):
    master_id, salt = server.prepare_submission()
    hash = self.make_hash(self.encoded_data, salt.encode())
    server.submit_timestamp(hash, master_id)
    
server_list = [TimestampServer('http://fts-ruby.herokuapp.com/api/v1')]

def check_cert(tsfile):
  cert="derp"
  if os.path.isfile(tsfile):
    try:
      f = open(tsfile, "r+")
      cert = json.loads(f.read())
      f.seek(0)
      f.write(json.dumps(cert))
      f.close()
    except ValueError:
      print("Malformed Certificate File!!")
  else:
    f = open(tsfile, "w")
    f.write('{"submitions":[],"blocks":[],"master_blocks":[]}')
    cert = json.loads('{"submitions":[],"blocks":[],"master_blocks":[]}')
    f.close()
  return cert

def do_submit(args):
  check_cert(args.cert or args.file.name + '.tscert')
  request = TimestampRequest(args.file)
  for server in server_list:
    request.submit_to(server)


#def do_certificate(args):

#def do_verify(args):
#  request = TimestampRequest(args.file)
#  for server in server_list:
#    ts = request.search_for_hash(server)

# setup command line parser
parser = argparse.ArgumentParser(prog='fts')
parser.add_argument('-c', '--cert')
cmdparsers = parser.add_subparsers()

# 'submit' command parser
parser_submit = cmdparsers.add_parser('submit')
parser_submit.add_argument('file', type=argparse.FileType('r'))
parser_submit.set_defaults(func=do_submit)

# 'verify' command parserserver_list = [TimestampServer('http://fts-ruby.herokuapp.com')]
#parser_verify = cmdparsers.add_parser('verify')
#parser_verify.add_argument('file', type=argparse.FileType('r'))
#parser_verify.set_defaults(func=do_verify)

# do it live!
if __name__ == "__main__":
  args = parser.parse_args()
  sys.exit( args.func(args) )
